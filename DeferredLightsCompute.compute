// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel UpsampleOutput
#pragma kernel DownsampleInput
#pragma kernel ComputeLights
#pragma kernel DownsampleDepth

#include "UnityCG.cginc"

float _RenderScale;

float2 _InputSize;
RWTexture2D<float4> _DeferredColorTexture;
RWTexture2D<float4> _DeferredLightsTexture;

float2 _OutputSize;
RWTexture2D<float4> _DeferredOutputTexture;

Texture2D<float4> _DownsampleColorInput;

[numthreads(32,18,1)]
void UpsampleOutput (uint3 id : SV_DispatchThreadID)
{
    float4 light = _DeferredLightsTexture[id.xy];
    float3 lightStrength = light.rgb * light.a;

    // float4 col = _DeferredColorTexture[id.xy];
    // col.rgb += (light.rgb * light.a);

    float2 diff = 1.0 / (_InputSize / _OutputSize);

    for (int i = 0; i < diff.x; i++)
    {
        for (int j = 0; j < diff.y; j++)
        {
            float2 samplePos = id.xy * (1 / _RenderScale) + float2(i, j);

            float4 colSample = _DownsampleColorInput[samplePos];
            colSample.rgb += (light.rgb * light.a);

            _DeferredOutputTexture[samplePos] = colSample;
        }
    }
}

[numthreads(32,18,1)]
void DownsampleInput (uint3 id : SV_DispatchThreadID)
{
    const float3x3 DownsampleKernel =
        float3x3(
            0.015625, 0.046875, 0.015625,
            0.046875, 0.75, 0.046875,
            0.015625, 0.046875, 0.015625
        );

    float4 avgCol = 0;
    for (int i = -1; i <= 1; i++)
    {
        for (int j = -1; j <= 1; j++)
        {
            float2 offset = float2(i, j);
            avgCol += _DownsampleColorInput[id.xy + offset] * DownsampleKernel[offset.x][offset.y];
        }
    }

    _DeferredColorTexture[id.xy * _RenderScale] = avgCol;
}

// ###########################
// #### LIGHTS START HERE ####
// ###########################

uint _DebugMode;

struct LightData
{
    float3 Position;
    float3 Color;
    float Intensity;
    float Range;
};

StructuredBuffer<LightData> _LightData;
uint _LightCount;
float4x4 _MVP;
float3 _CameraPos;

RWTexture2D<float> _DepthTexture;
Texture2D<float> _DownsampleDepthInput;

[numthreads(32,18,1)]
void DownsampleDepth (uint3 id : SV_DispatchThreadID)
{
    _DepthTexture[id.xy * _RenderScale] = _DownsampleDepthInput[id.xy].r;
}

Texture2D<float4> _DepthNormalsTexture;
Texture2D<float4> _WorldPositionsTexture; 

float3 DecodeNormal(float4 enc)
{
    float kScale = 1.7777;
    float3 nn = enc.xyz*float3(2*kScale,2*kScale,0) + float3(-kScale,-kScale,1);
    float g = 2.0 / dot(nn.xyz,nn.xyz);
    float3 n;
    n.xy = g*nn.xy;
    n.z = g-1;
    return n;
}

[numthreads(32,18,1)]
void ComputeLights (uint3 id : SV_DispatchThreadID)
{
    float4 depthNormal = _DepthNormalsTexture[id.xy];
    float3 normal = DecodeNormal(depthNormal);
    float depth = _DepthTexture[id.xy].r;

    float3 worldPos = _WorldPositionsTexture[id.xy].xyz;

    if (_DebugMode != 0)
    { 
        const int NormalsDebugMode = _DebugMode == 1;
        const int DepthDebugMode = _DebugMode == 2;
        const int PositionsDebugMode = _DebugMode == 3;

        _DeferredLightsTexture[id.xy] = 
            float4(depth, depth, depth, 1.0) * DepthDebugMode + 
            float4(normal, 1.0) * NormalsDebugMode + 
            float4(worldPos, 1.0) * PositionsDebugMode;
        return;
    }

    _DeferredLightsTexture[id.xy] = float4(0,0,0,0);
    float4 accLight = 0;

    [loop]
    for (int i = 0; i < _LightCount; i++)
    {
        LightData ld = _LightData[i];

        float dist = saturate(distance(worldPos, ld.Position) / ld.Range);
        if (dist >= 1.0) continue;

        float intensity = saturate(exp(-6 * dist * dist)) * ld.Intensity;
        float4 col = float4(ld.Color, intensity);

        accLight += col;
    }
    
    accLight.a = saturate(accLight.a);
    accLight.rgb = normalize(accLight.rgb);
    _DeferredLightsTexture[id.xy] = accLight;
} 